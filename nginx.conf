user nginx nginx;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;
events {
    worker_connections 1024;
}
http {
    include /etc/nginx/mime.types;
    include /etc/nginx/conf.d/*; # add any additional/custom server blocks
    map_hash_bucket_size 128;
    # Resolver (IPv4 only per request)
    resolver 1.1.1.1 1.0.0.1 valid=300s;
    resolver_timeout 10s;
    # ddos protection
    client_body_timeout 10s;
    client_header_timeout 10s;
    proxy_connect_timeout 20s;
    # these are very lenient limits. there should be no reason why a
    # client will request 60 requests per second for a straight 8.33 seconds
    limit_req_zone $binary_remote_addr zone=limitreq:20m rate=30r/s;
    limit_req zone=limitreq burst=500 nodelay;
    limit_req_status 429;
    limit_conn_zone $binary_remote_addr zone=limitconn:20m;
    limit_conn limitconn 50;
    # handle big upstream headers (lots of Set-Cookie)
    large_client_header_buffers 8 64k;
    # compress responses back to clients (we fetch identity from upstream where rewriting)
    gzip on;
    gzip_comp_level 5;
    gzip_min_length 1024;
    gzip_vary on;
    gzip_types
    text/plain text/css text/javascript application/javascript application/x-javascript
    application/json application/xml application/xhtml+xml image/svg+xml;
    # Cache key varies by encoding to avoid cross-encoding cache pollution
    map $http_accept_encoding $cache_ae {
        ~*br     "br";
        ~*gzip   "gzip";
        default  "identity";
    }
    # optional proxy cache for static-ish assets
    proxy_cache_path /var/cache/nginx/womg levels=1:2 keys_zone=womg:100m max_size=5g inactive=1h use_temp_path=off;
    # domain blacklist. blacklisting www.example.com as an example
    map $dest_host $blacklist {
        default 0;
        'www.example.com' 1;
    }
    # blacklist user agents
    # the following is a default list that simply blocks all bots. credit to https://stackoverflow.com/a/24820722
    map $http_user_agent $blacklist_useragent {
        default 0;
        ~*(google|bing|yandex|msnbot) 1;
        ~*(AltaVista|Googlebot|Slurp|BlackWidow|Bot|ChinaClaw|Custo|DISCo|Download|Demon|eCatch|EirGrabber|EmailSiphon|EmailWolf|SuperHTTP|Surfbot|WebWhacker) 1;
        ~*(Express|WebPictures|ExtractorPro|EyeNetIE|FlashGet|GetRight|GetWeb!|Go!Zilla|Go-Ahead-Got-It|GrabNet|Grafula|HMView|Go!Zilla|Go-Ahead-Got-It) 1;
        ~*(rafula|HMView|HTTrack|Stripper|Sucker|Indy|InterGET|Ninja|JetCar|Spider|larbin|LeechFTP|Downloader|tool|Navroad|NearSite|NetAnts|tAkeOut|WWWOFFLE) 1;
        ~*(GrabNet|NetSpider|Vampire|NetZIP|Octopus|Offline|PageGrabber|Foto|pavuk|pcBrowser|RealDownload|ReGet|SiteSnagger|SmartDownload|SuperBot|WebSpider) 1;
        ~*(Teleport|VoidEYE|Collector|WebAuto|WebCopier|WebFetch|WebGo|WebLeacher|WebReaper|WebSauger|eXtractor|Quester|WebStripper|WebZIP|Wget|Widow|Zeus) 1;
        ~*(Twengabot|htmlparser|libwww|Python|perl|urllib|scan|Curl|email|PycURL|Pyth|PyQ|WebCollector|WebCopy|webcraw) 1;
    }
    # set scheme appropriately in case nginx is sitting behind servers like heroku
    map $http_x_forwarded_proto $relativescheme {
        default $http_x_forwarded_proto;
        '' $scheme;
    }
    # websocket headers
    map $http_upgrade $connection_upgrade {
        default Upgrade;
        '' close;
    }
    map '' $proxy_prefix {
        default $relativescheme://$host;
    }
    # Extract host from target (support http/https/ws/wss)
    map $targeturl $dest_host {
        default '';
        ~^(?:https?|wss?)://([^/]+) $1;
    }
    map $targeturl $dest_fullwebsocketurl {
        default $targeturl;
        ~^ws(s)?://(.+)(\?womginx_ws_origin_header=.+)$ http$1://$2;
        ~^ws(s)?://(.+) http$1://$2;
    }
    # Proper Origin scheme for WS targets (wss->https, ws->http)
    map $targeturl $ws_origin_scheme {
        default "";
        ~^wss:// https;
        ~^ws://  http;
    }
    # get targeturl destination from referrer
    map $http_referer $dest_referrerhost {
        default '';
        ~^https?://[^/]+/main(/[^_/]+_)?/(?<targeturl>https?://?[^/]+) $targeturl;
    }
    # use $request_uri for proxy cookie rewriting where there is no $targeturl variable
    # Fixed to properly capture scheme and host including ports
    map $request_uri $dest_hostwithscheme {
        default '';
        ~^/main(/[^_/]+_)?/((?:https?|wss?)://[^/]+) $2;
    }
    # header rewrites
    map $http_referer $rewrite_referer {
        default $http_referer;
        ~^https?://[^/]+/main(/[^_/]+_)?/(?<targeturl>.*) $targeturl;
    }
    # rewrite origin header with destination host. if that doesn't exist, don't rewrite it
    # also, get origin header from websocket request, prioritizing over $http_origin if that exists (see $dest_fullwebsocketurl)
    map $http_origin:womginxseparate:$request_uri $rewrite_origin {
        default $dest_hostwithscheme;
        # origin maybe exists, womginx_ws_origin_header exists
        ~^.+(\?womginx_ws_origin_header=(.+))$ $2;
        # origin and womginx_ws_origin_header doesn't exist
        ~^:womginxseparate: '';
    }
    # undo merged slashes from wombat-handler.js in WS origin header
    map $rewrite_origin $reslashed_origin {
        default $rewrite_origin;
        ~^(https?:/)([^/].*) $1/$2;
    }
    server {
        server_name womginx.arph.org localhost 127.0.0.1;
        listen 80;
        ssl_certificate /etc/letsencrypt/live/womginx.arph.org/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/womginx.arph.org/privkey.pem;
        server_tokens off;
        merge_slashes off;
        proxy_ssl_server_name on;
        error_page 404 = @referrer-handler;
        # use undecoded uri as location for proxying encoded urls
        rewrite ^ $request_uri;
        # convert /main/http:/google.com to /main/http://google.com internally without redirect
        rewrite ^\/main(?<mod>\/[^\/_]+_)?(?<url_preslash>\/(?:http|ws)s?:\/)(?<url_postslash>[^\/].*) /main$mod$url_preslash/$url_postslash;
        # convert /main/http://domain.com to /main/http://domain.com/
        # convert /main/http://domain.com?a to /main/http://domain.com/?a
        rewrite ^(/main/https?://[^/?]*)/?(.*) $1/$2;
        set $womginx_cookie 'womginx_are_you_a_bot=no; Path=/; HttpOnly; Secure';
        # Seamlessly add womginx cookie to improve UX
        # example: /womginxaddcookie/1725822290/https://womginxserver/main/https://www.google.com
        location ~^/womginxaddcookie/\d+/(.+) {
            add_header Set-Cookie $womginx_cookie;
            add_header Cache-Control "no-store" always;
            return 302 $1;
        }
        #### static file requests handling ####
        # serve static files, disallow access to .git directories, and ignore prefixes starting with /main/
        location ~^((?!/\.git|^/main/).)*$ {
            add_header 'Set-Cookie' $womginx_cookie;
            alias /home/binary/womginx/public$uri;
            # if no file is found, pass it to @referrer-handler
        }
        location = / {
            if ($dest_referrerhost = '') {
                rewrite ^ /index.html last;
            }
            # if no file exists, pass it to @referrer-handler
            return 404;
        }
        # catch links like '/assets.png' and redirect them by their referrer if referrer is valid
        location @referrer-handler {
            # if referrer doesn't exist, send 404 page
            if ($dest_referrerhost = '') {
                return 404;
            }
            # if it exists, send appropriate redirection
            return 302 $proxy_prefix/main/$dest_referrerhost$request_uri;
        }

        #### proxy requests handling ####
        location /main {
            # Explicit host and HTTP/1.1 (helps chunked/SSE)
            proxy_http_version 1.1;
            proxy_set_header Host $dest_host;
            proxy_read_timeout 90s;
            proxy_send_timeout 90s;
            # SNI for variable proxy_pass
            proxy_ssl_name $dest_host;
            # Forward useful headers for upstream apps
            proxy_set_header X-Forwarded-Host $host;
            proxy_set_header X-Forwarded-Proto $relativescheme;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            # disable upstream compression where we sub_filter (overridden below for pure assets)
            proxy_set_header Accept-Encoding 'identity;q=1, *;q=0';
            # hide headers that commonly break proxied apps
            proxy_hide_header Content-Security-Policy;
            proxy_hide_header Content-Security-Policy-Report-Only;
            proxy_hide_header Cross-Origin-Opener-Policy;
            proxy_hide_header Cross-Origin-Embedder-Policy;
            proxy_hide_header Cross-Origin-Resource-Policy;
            proxy_hide_header Strict-Transport-Security;
            proxy_hide_header X-Frame-Options;
            proxy_hide_header Permissions-Policy;
            proxy_hide_header Clear-Site-Data;
            proxy_hide_header Report-To;
            proxy_hide_header NEL;
            proxy_hide_header Alt-Svc;
            proxy_hide_header Expect-CT;
            # rewrite referer header
            proxy_set_header Referer $rewrite_referer;
            # rewrite origin header
            proxy_set_header Origin $reslashed_origin;
            # rewrite cookie domain and path
            proxy_cookie_domain ~(.*) $host;
            proxy_cookie_path ~(/.*) /main/$dest_hostwithscheme$1;
            # ensure upstream cookies remain usable when proxied cross-site
            proxy_cookie_flags ~ secure samesite=None;
            # websocket headers
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection $connection_upgrade;
            # fix "upstream sent too big header/body"
            proxy_buffer_size 16k;
            proxy_busy_buffers_size 24k;
            proxy_buffers 4 16k;
            # client can only upload files less than 100M
            client_max_body_size 100M;

            # rewrite relative urls like /main/// to /main/https:// internally without redirect
            location ~^/main(/[^_/]+_)?///(?<protocol_relative_url>.+) {
                rewrite ^/main(/[^_/]+_)?///(?<protocol_relative_url>.+) /main$1/$relativescheme://$protocol_relative_url last;
            }
            # redirect any url with /main/google.com to /main/https://google.com
            location ~^/main(/[^/_]+_)?(?!(/[^/_]+_)?/(http|ws)s?://|//)/(?<rewrite_url_with_scheme>.*) {
                return 302 $proxy_prefix/main$1/$relativescheme://$rewrite_url_with_scheme;
            }
            # handle websocket connections
            location ~^/main/\d*ws_/(?<targeturl>.+){
                proxy_http_version 1.1;
                # WebSocket upgrade headers (explicit)
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection $connection_upgrade;
                # Ensure upstream sees correct Host
                proxy_set_header Host $dest_host;
                # Determine effective Origin: prefer $reslashed_origin if set, else derive from ws scheme
                set $effective_origin $reslashed_origin;
                if ($effective_origin = '') {
                    set $effective_origin "$ws_origin_scheme://$dest_host";
                }
                proxy_set_header Origin $effective_origin;
                # Usual forwards
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
                # Don't buffer WS frames
                proxy_buffering off;
                proxy_request_buffering off;
                proxy_read_timeout 3600s;
                proxy_send_timeout 3600s;
                proxy_ssl_server_name on;
                proxy_ssl_name $dest_host;
                proxy_pass $dest_fullwebsocketurl;
            }
            # serve assets (images/other). allow upstream compression and enable cache
            location ~^/main/\d*(im|oe)_/(?<targeturl>.+) {
                proxy_set_header Accept-Encoding $http_accept_encoding;
                proxy_cache womg;
                proxy_cache_key "$scheme$proxy_host$request_uri::$cache_ae";
                proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
                proxy_cache_lock on;
                proxy_cache_background_update on;
                proxy_cache_revalidate on;
                proxy_cache_valid 200 301 302 1h;
                proxy_cache_valid any 10m;
                add_header X-Cache-Status $upstream_cache_status always;
                # Range support for media
                proxy_set_header Range $http_range;
                proxy_set_header If-Range $http_if_range;
                proxy_force_ranges on;
                proxy_pass $targeturl;
            }
            # service/web workers: rewrite importScripts/fetch/etc
            location ~^/main/\d*(wkr|sw)_/(?<targeturl>.+) {
                proxy_set_header Accept-Encoding 'identity;q=1, *;q=0';
                subs_filter_types *;
                # Fixed string replacements
                subs_filter '__WOMGINX_TARGET_URL__' '$targeturl' g;
                subs_filter '.postMessage(' '.__WB_pmw(self.window).postMessage(' g;
                subs_filter '.postMessage (' '.__WB_pmw(self.window).postMessage (' g;
                subs_filter 'window.location' 'window.currentLocation' g;
                subs_filter 'location' 'currentLocation' g;
                # JSON fixes - prevent double rewriting
                subs_filter "([:\s,])(['\"])(?!/main/)(https://)" "$1$2/main/$3" gr;
                # Integrity bypass
                subs_filter "([,\s{])integrity:" "$1nointegrity:" gr;
                subs_filter "(['\"])integrity(['\"]):" "$1nointegrity$2:" gr;
                # Concatenated URLs
                subs_filter "(['\"])(?!/main/)(https://)(['\"])\+" "$1/main/$2$3+" gr;
                # JS API rewrites with negative lookahead - FIXED with proper parentheses
                subs_filter "(importScripts|import|fetch|new\s+(?:Request|URL|EventSource|Worker|SharedWorker)|navigator\.sendBeacon)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "$1($2/main/$3" gir;
                subs_filter "(importScripts|import|fetch|new\s+(?:Request|URL|EventSource|Worker|SharedWorker)|navigator\.sendBeacon)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]*)" "$1($2/main/$dest_hostwithscheme$3" gir;
                # WebSocket special case
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/)(wss?://[^'\"]+)" "new WebSocket($1/main/ws_/$2" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/|wss?://|//)(/[^'\"]*)" "new WebSocket($1/main/ws_/$dest_hostwithscheme$2" gir;
                # Workers special routing
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "new $1($2/main/wkr_/$3" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]*)" "new $1($2/main/wkr_/$dest_hostwithscheme$3" gir;
                proxy_cache womg;
                proxy_cache_key "$scheme$proxy_host$request_uri::$cache_ae";
                proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
                proxy_cache_lock on;
                proxy_cache_background_update on;
                proxy_cache_revalidate on;
                proxy_cache_valid 200 301 302 5m;
                proxy_cache_valid any 1m;
                proxy_hide_header Service-Worker-Allowed;
                add_header X-Cache-Status $upstream_cache_status always;
                add_header Service-Worker-Allowed "/main/" always;
                proxy_pass $targeturl;
            }
            location ~^/main/\d*cs_/(?<targeturl>.+) {
                rewrite ^ /main/css_/$targeturl$is_args$args last;
            }
            location ~^/main/(?<targeturl>https?://[^/]+/.+?\.css(?:\?.*)?)$ {
                rewrite ^ /main/css_/$targeturl$is_args$args last;
            }
            # CSS rewriter route - FIXED with proper parentheses
            location ~^/main/\d*css_/(?<targeturl>.+) {
                proxy_set_header Accept-Encoding 'identity;q=1, *;q=0';
                subs_filter_types text/css text/plain application/javascript;
                # Single comprehensive CSS regex pattern - FIXED
                # Captures: @import or url( with optional quotes, then the URL
                # Handle absolute URLs (http/https)
                subs_filter "(@import\s+|url\s*\()(['\"]?)(?!/main/|data:|blob:)(https?://[^'\"\)\s]+)(['\"]?[\);])" "$1$2/main/$3$4" gir;
                # Handle protocol-relative URLs (//)
                subs_filter "(@import\s+|url\s*\()(['\"]?)(?!/main/|https?://|data:|blob:)(//[^'\"\)\s]+)(['\"]?[\);])" "$1$2/main/$relativescheme:$3$4" gir;
                # Handle root-relative URLs (/)
                subs_filter "(@import\s+|url\s*\()(['\"]?)(?!/main/|https?://|//|data:|blob:)(/[^'\"\)\s]+)(['\"]?[\);])" "$1$2/main/$dest_hostwithscheme$3$4" gir;
                proxy_cache womg;
                proxy_cache_key "$scheme$proxy_host$request_uri::$cache_ae";
                proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
                proxy_cache_lock on;
                proxy_cache_background_update on;
                proxy_cache_revalidate on;
                proxy_cache_valid 200 301 302 10m;
                proxy_cache_valid any 2m;
                add_header X-Cache-Status $upstream_cache_status always;
                proxy_pass $targeturl;
            }
            # JS rewriter route - FIXED with proper parentheses
            location ~^/main/\d*js_/(?<targeturl>.+) {
                subs_filter_types *;
                # Fixed string replacements
                subs_filter '.postMessage(' '.__WB_pmw(self.window).postMessage(' g;
                subs_filter '.postMessage (' '.__WB_pmw(self.window).postMessage (' g;
                subs_filter 'window.location' 'window.currentLocation' g;
                subs_filter 'location' 'currentLocation' g;
                # Dynamic imports and from statements - FIXED
                subs_filter "(import\s*\(|from\s+)(['\"])(?!/main/)(https?://[^'\"]+)" "$1$2/main/$3" gir;
                subs_filter "(import\s*\(|from\s+)(['\"])(?!/main/|https?://)//([^'\"]+)" "$1$2/main/$relativescheme://$3" gir;
                subs_filter "(import\s*\(|from\s+)(['\"])(?!/main/|https?://|//)(/[^'\"]+)" "$1$2/main/$dest_hostwithscheme$3" gir;
                # JS APIs with negative lookahead - FIXED
                subs_filter "(fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "$1($2/main/$3" gir;
                subs_filter "(fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/|https?://)//([^'\"]+)" "$1($2/main/$relativescheme://$3" gir;
                subs_filter "(fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]+)" "$1($2/main/$dest_hostwithscheme$3" gir;
                # WebSocket
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/)(wss?://[^'\"]+)" "new WebSocket($1/main/ws_/$2" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/|wss?://)//([^'\"]+)" "new WebSocket($1/main/ws_/$relativescheme://$2" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/|wss?://|//)(/[^'\"]+)" "new WebSocket($1/main/ws_/$dest_hostwithscheme$2" gir;
                # Workers
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "new $1($2/main/wkr_/$3" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/|https?://)//([^'\"]+)" "new $1($2/main/wkr_/$relativescheme://$3" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]+)" "new $1($2/main/wkr_/$dest_hostwithscheme$3" gir;
                proxy_cache womg;
                proxy_cache_key "$scheme$proxy_host$request_uri::$cache_ae";
                proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
                proxy_cache_lock on;
                proxy_cache_background_update on;
                proxy_cache_revalidate on;
                proxy_cache_valid 200 301 302 10m;
                proxy_cache_valid any 2m;
                add_header X-Cache-Status $upstream_cache_status always;
                proxy_pass $targeturl;
            }
            # JS by extension (.js/.mjs) - FIXED with proper parentheses
            location ~^/main/(?<targeturl>https?://[^/]+/.+?\.(?:mjs|js)(?:\?.*)?)$ {
                proxy_set_header Accept-Encoding 'identity;q=1, *;q=0';
                subs_filter_types *;
                # Fixed string replacements
                subs_filter '.postMessage(' '.__WB_pmw(self.window).postMessage(' g;
                subs_filter '.postMessage (' '.__WB_pmw(self.window).postMessage (' g;
                subs_filter 'window.location' 'window.currentLocation' g;
                subs_filter 'location' 'currentLocation' g;
                # Same JS patterns as js_ location - FIXED
                subs_filter "(import\s*\(|from\s+)(['\"])(?!/main/)(https?://[^'\"]+)" "$1$2/main/$3" gir;
                subs_filter "(import\s*\(|from\s+)(['\"])(?!/main/|https?://)//([^'\"]+)" "$1$2/main/$relativescheme://$3" gir;
                subs_filter "(import\s*\(|from\s+)(['\"])(?!/main/|https?://|//)(/[^'\"]+)" "$1$2/main/$dest_hostwithscheme$3" gir;
                subs_filter "(fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "$1($2/main/$3" gir;
                subs_filter "(fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/|https?://)//([^'\"]+)" "$1($2/main/$relativescheme://$3" gir;
                subs_filter "(fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]+)" "$1($2/main/$dest_hostwithscheme$3" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/)(wss?://[^'\"]+)" "new WebSocket($1/main/ws_/$2" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/|wss?://)//([^'\"]+)" "new WebSocket($1/main/ws_/$relativescheme://$2" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/|wss?://|//)(/[^'\"]+)" "new WebSocket($1/main/ws_/$dest_hostwithscheme$2" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "new $1($2/main/wkr_/$3" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/|https?://)//([^'\"]+)" "new $1($2/main/wkr_/$relativescheme://$3" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]+)" "new $1($2/main/wkr_/$dest_hostwithscheme$3" gir;
                proxy_cache womg;
                proxy_cache_key "$scheme$proxy_host$request_uri::$cache_ae";
                proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
                proxy_cache_lock on;
                proxy_cache_background_update on;
                proxy_cache_revalidate on;
                proxy_cache_valid 200 301 302 10m;
                proxy_cache_valid any 2m;
                add_header X-Cache-Status $upstream_cache_status always;
                proxy_pass $targeturl;
            }
            # redirect any url with /main/unsupportedmod_/blahblah to /main/blahblah
            location ~ ^/main/[^_/]+_/(?<redirecttargeturl>https?://.+) {
                return 302 $proxy_prefix/main/$redirecttargeturl;
            }
            # Could be problematic if debugging then possibly comment out this
            location ~^/main/[^_/]+_/(?<redirecttargeturl>.+) {
                rewrite ^ /main/$redirecttargeturl last;
            }
            # HTML catch-all - FIXED with proper parentheses
            location ~^/main/(?<targeturl>.*)$ {
                # blacklist urls
                if ($blacklist) {
                    return 403 'Sorry. The owner of this proxy decided to disallow access to this content.';
                }
                # blacklist user agents
                if ($blacklist_useragent) {
                    return 403 'Sorry, you are not allowed to access this content.';
                }
                # handle proxy sending redirection requests
                proxy_redirect ~^(https?://.+) $proxy_prefix/main/$1;
                subs_filter_types text/html;
                set $processed_flag_attribute 'womginx-processed';
                # FIRST: Remove ALL HTML comments more robustly (handles multiline)
                subs_filter "<!--.*?-->" "" grs;
                # HTML attributes with negative lookahead to prevent double-rewriting
                subs_filter "(\s+(?:href|src|srcset|action)=)(['\"])(?!/main/|data:|blob:|javascript:)(https?://[^'\"]+)(['\"])" "$1$2/main/$3$4" gir;
                subs_filter "(\s+(?:href|src|srcset|action)=)(['\"])(?!/main/|https?://|data:|blob:|javascript:)//([^'\"]+)(['\"])" "$1$2/main/$relativescheme://$3$4" gir;
                subs_filter "(\s+(?:href|src|srcset|action)=)(['\"])(?!/main/|https?://|//|data:|blob:|javascript:)(/[^'\"]+)(['\"])" "$1$2/main/$dest_hostwithscheme$3$4" gir;
                # Add processed flag to attributes
                subs_filter "(\s+)(href|src|srcset|action)(=)" "$1$processed_flag_attribute $2$3" gir;
                # meta content attribute
                subs_filter "(\s+content=)(['\"])(?!/main/|data:|blob:)(https?://[^'\"]+)(['\"])" "$1$2/main/$3$4" gir;
                subs_filter "(\s+content=)(['\"])(?!/main/|https?://|data:|blob:)//([^'\"]+)(['\"])" "$1$2/main/$relativescheme://$3$4" gir;
                subs_filter "(\s+content=)(['\"])(?!/main/|https?://|//|data:|blob:)(/[^'\"]+)(['\"])" "$1$2/main/$dest_hostwithscheme$3$4" gir;
                # meta refresh url=
                subs_filter "(url=)(?!/main/|data:|blob:)(https?://[^'\"\s]+)" "$1/main/$2" gir;
                subs_filter "(url=)(?!/main/|https?://|data:|blob:)//([^'\"\s]+)" "$1/main/$relativescheme://$2" gir;
                subs_filter "(url=)(?!/main/|https?://|//|data:|blob:)(/[^'\"\s]+)" "$1/main/$dest_hostwithscheme$2" gir;
                # inline CSS url() - FIXED with proper parentheses
                subs_filter "(url\s*\()(['\"]?)(?!/main/|data:|blob:)(https?://[^'\"\)\s]+)(['\"]?\))" "$1$2/main/$3$4" gir;
                subs_filter "(url\s*\()(['\"]?)(?!/main/|https?://|data:|blob:)(//[^'\"\)\s]+)(['\"]?\))" "$1$2/main/$relativescheme:$3$4" gir;
                subs_filter "(url\s*\()(['\"]?)(?!/main/|https?://|//|data:|blob:)(/[^'\"\)\s]+)(['\"]?\))" "$1$2/main/$dest_hostwithscheme$3$4" gir;
                # Disable integrity and CSP
                subs_filter "(integrity)=(['\"])" "no$1=$2" gir;
                subs_filter "(http-equiv=)(['\"])Content-Security-Policy(['\"])" "$1$2No-U-Content-Security-Policy$3" gir;
                # Inline JS patterns - FIXED with proper parentheses
                subs_filter "(import\s*\(|fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "$1($2/main/$3" gir;
                subs_filter "(import\s*\(|fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/|https?://)//([^'\"]+)" "$1($2/main/$relativescheme://$3" gir;
                subs_filter "(import\s*\(|fetch|new\s+(?:Request|URL|EventSource)|navigator\.sendBeacon)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]+)" "$1($2/main/$dest_hostwithscheme$3" gir;
                # WebSocket in inline scripts
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/)(wss?://[^'\"]+)" "new WebSocket($1/main/ws_/$2" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/|wss?://)//([^'\"]+)" "new WebSocket($1/main/ws_/$relativescheme://$2" gir;
                subs_filter "new\s+WebSocket\s*\((['\"])(?!/main/|wss?://|//)(/[^'\"]+)" "new WebSocket($1/main/ws_/$dest_hostwithscheme$2" gir;
                # Workers in inline scripts
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/)(https?://[^'\"]+)" "new $1($2/main/wkr_/$3" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/|https?://)//([^'\"]+)" "new $1($2/main/wkr_/$relativescheme://$3" gir;
                subs_filter "new\s+(Worker|SharedWorker)\s*\((['\"])(?!/main/|https?://|//)(/[^'\"]+)" "new $1($2/main/wkr_/$dest_hostwithscheme$3" gir;
                # Fixed string replacements
                subs_filter 'window.location' 'window.currentLocation' g;
                subs_filter 'self.location' 'self.currentLocation' g;
                # insert wombat.js and wombat-handler.js scripts
                subs_filter '<head>' '<head>
    <script $processed_flag_attribute src="/wombat/dist/wombat.js"></script>
    <script $processed_flag_attribute src="/wombat-handler.js" processed-attribute="$processed_flag_attribute">
    </script>' i;
                proxy_pass $targeturl;
            }
        }
    }
}
